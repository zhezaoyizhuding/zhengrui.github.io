<!doctype html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="排序," />





  <link rel="alternate" href="/atom.xml" title="ZHENGRUI'BLOG" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="排序是基本的算法之一，也是在面试中被问的最多的问题。即将开始找工作，便趁此机会复习一下这些早已被忘却的知识（估计之后我还会忘记它）。 排序如果按照程序运行的地点，可将它分为内部排序和外部排序。内部排序即是数据都放在内存中，但是有时候我们的数据量很大内存无法容纳，就需要将数据放在磁盘中，然后分段放入内存中排序。 排序算法有稳定和不稳定之分。所谓稳定性即是当序列中有两个相同的数据时，排序前和排序后它俩">
<meta name="keywords" content="排序">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="https://zhezaoyizhuding.github.io/2017/04/10/排序/index.html">
<meta property="og:site_name" content="ZHENGRUI&#39;BLOG">
<meta property="og:description" content="排序是基本的算法之一，也是在面试中被问的最多的问题。即将开始找工作，便趁此机会复习一下这些早已被忘却的知识（估计之后我还会忘记它）。 排序如果按照程序运行的地点，可将它分为内部排序和外部排序。内部排序即是数据都放在内存中，但是有时候我们的数据量很大内存无法容纳，就需要将数据放在磁盘中，然后分段放入内存中排序。 排序算法有稳定和不稳定之分。所谓稳定性即是当序列中有两个相同的数据时，排序前和排序后它俩">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-02-07T15:44:13.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序">
<meta name="twitter:description" content="排序是基本的算法之一，也是在面试中被问的最多的问题。即将开始找工作，便趁此机会复习一下这些早已被忘却的知识（估计之后我还会忘记它）。 排序如果按照程序运行的地点，可将它分为内部排序和外部排序。内部排序即是数据都放在内存中，但是有时候我们的数据量很大内存无法容纳，就需要将数据放在磁盘中，然后分段放入内存中排序。 排序算法有稳定和不稳定之分。所谓稳定性即是当序列中有两个相同的数据时，排序前和排序后它俩">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: 'JRBAME0VLD',
      apiKey: 'b62ed43f602517ec39140c839edfa335',
      indexName: 'ZHENGRUI',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhezaoyizhuding.github.io/2017/04/10/排序/"/>





  <title> 排序 | ZHENGRUI'BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  














  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZHENGRUI'BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">读书、健身、旅行</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zhezaoyizhuding.github.io/2017/04/10/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhengrui">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/海贼3.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZHENGRUI'BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                排序
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-10T12:14:01+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/10/排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/10/排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/04/10/排序/" class="leancloud_visitors" data-flag-title="排序">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>排序是基本的算法之一，也是在面试中被问的最多的问题。即将开始找工作，便趁此机会复习一下这些早已被忘却的知识（估计之后我还会忘记它）。</p>
<p>排序如果按照程序运行的地点，可将它分为内部排序和外部排序。内部排序即是数据都放在内存中，但是有时候我们的数据量很大内存无法容纳，就需要将数据放在磁盘中，然后分段放入内存中排序。</p>
<p>排序算法有稳定和不稳定之分。所谓稳定性即是当序列中有两个相同的数据时，排序前和排序后它俩的顺序不变，能实现这种情况的排序算法我们说他是稳定的。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>插入排序的基本思想是将一个记录插入到已经排好序的序列中，它默认将第一个元素视为一个已经排好序的序列，后面的元素从后向前逐个扫描，插入到相应位置。时间复杂度O(n^2),空间复杂度O(1)。这种排序是稳定的。</p>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ul>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;arraytoSort.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>( arraytoSort[j+<span class="number">1</span>] &lt; arraytoSort[j] )&#123;</span><br><span class="line">                    temp = arraytoSort[j+<span class="number">1</span>];</span><br><span class="line">                    arraytoSort[j+<span class="number">1</span>] = arraytoSort[j];</span><br><span class="line">                    arraytoSort[j] = temp;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序也是插入排序的一种，又叫缩小增量排序。这种排序会设置一个增量（这个增量决定排序效率的高低），然后根据这个增量将整个序列分为若干个子序列，我们可以将这些子序列排成一个增量长的表，分别对每列进行排序，这叫做一趟。然后增量递减，像上述这样进行多趟排序，直到增量为1，此时的最后一趟排序即为直接插入排序。</p>
<p>例如有这样的一组数[49,38,65,97,76,13,27,<strong>49</strong>,55,04],我们以初始增量为5来进行多趟排序，如下：</p>
<p>第一趟：（增量为5）</p>
<p>49 38 65 97 76<br>13 27 <strong>49</strong> 55 04</p>
<p>排序结果为:</p>
<p>13 27 <strong>49</strong> 55 04<br>49 38 65 97 76</p>
<p>合成一列为：[13,27,<strong>49</strong>,55,04,49,38,65,97,76]</p>
<p>第二趟：（增量为4）</p>
<p>13 27 <strong>49</strong> 55<br>04 49 38 65<br>97 76</p>
<p>排序结果：</p>
<p>04 27 38 55<br>13 49 <strong>49</strong> 65<br>97 76</p>
<p>合成一列为：[04,27,38,55,13，49，<strong>49</strong>，65，97，76]</p>
<p>第三趟：（增量为3）</p>
<p>04 27 38<br>55 13 49<br><strong>49</strong> 65 97<br>76</p>
<p>排序结果：</p>
<p>04 13 38<br><strong>49</strong> 27 49<br>55 65 97<br>76</p>
<p>合成一列为：[04,13,38,<strong>49</strong>,27,49,55,65,97,76]</p>
<p>第四趟：（增量为2）</p>
<p>04 13<br>38 <strong>49</strong><br>27 49<br>55 65<br>97 76</p>
<p>排序结果：</p>
<p>04 13<br>27 <strong>49</strong><br>38 49<br>55 65<br>97 76</p>
<p>合成一列为：[04,13,27,<strong>49</strong>,38,49,55,65,97,76]</p>
<p>最后一趟，增量为1，即为直接插入排序。此时序列已基本有序，排序效率大大提高。</p>
<p>结果：[04,13,27,38，<strong>49</strong>,49,55,65,76,97]</p>
<p>从结果能看到，希尔排序为不稳定排序。它的排序效率有所选择的增量决定。</p>
<h6 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123;  </span><br><span class="line">    cout&lt;&lt;i &lt;&lt;<span class="string">":"</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;  </span><br><span class="line">        cout&lt;&lt;a[j] &lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序的一般形式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int dk 缩小增量，如果是直接插入排序，dk=1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> dk)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= dk; i&lt;n; ++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i-dk])&#123;          <span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入  </span></span><br><span class="line">            <span class="keyword">int</span> j = i-dk;     </span><br><span class="line">            <span class="keyword">int</span> x = a[i];           <span class="comment">//复制为哨兵，即存储待排序元素  </span></span><br><span class="line">            a[i] = a[i-dk];         <span class="comment">//首先后移一个元素  </span></span><br><span class="line">            <span class="keyword">while</span>(x &lt; a[j])&#123;     <span class="comment">//查找在有序表的插入位置  </span></span><br><span class="line">                a[j+dk] = a[j];  </span><br><span class="line">                j -= dk;             <span class="comment">//元素后移  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            a[j+dk] = x;            <span class="comment">//插入到正确位置  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        print(a, n,i );  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先按增量d（n/2,n为要排序数的个数进行希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dk = n/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>( dk &gt;= <span class="number">1</span>  )&#123;  </span><br><span class="line">        ShellInsertSort(a, n, dk);  </span><br><span class="line">        dk = dk/<span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;  </span><br><span class="line">    <span class="comment">//ShellInsertSort(a,8,1); //直接插入排序  </span></span><br><span class="line">    shellSort(a,<span class="number">8</span>);           <span class="comment">//希尔插入排序  </span></span><br><span class="line">    print(a,<span class="number">8</span>,<span class="number">8</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>选择排序的思路很简单，即是扫描未排序的序列，然后将序列中最大（或者最小）的元素放在前面已经排好序的序列的末尾。时间复杂度O(n^2),空间复杂度O(1)。</p>
<h5 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arraytoSort.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="comment">//find min</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;arraytoSort.length ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arraytoSort[j] &lt;arraytoSort[min])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//swap the min with the ith element</span></span><br><span class="line">            temp = arraytoSort[min];</span><br><span class="line">            arraytoSort[min] = arraytoSort[i];</span><br><span class="line">            arraytoSort[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单选择排序的改进–二元选择排序"><a href="#简单选择排序的改进–二元选择排序" class="headerlink" title="简单选择排序的改进–二元选择排序"></a>简单选择排序的改进–二元选择排序</h4><p>简单选择排序每趟循环只能确定一个元素的位置，我们可以考虑每趟循环确定两个元素的位置（当前趟最大和最小），从而减少排序所需的循环次数，来提升效率。</p>
<h5 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i ,j , min ,max, tmp;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span> ;i &lt;= n/<span class="number">2</span>;i++) &#123;    </span><br><span class="line">        <span class="comment">// 做不超过n/2趟选择排序   </span></span><br><span class="line">        min = i; max = i ; <span class="comment">//分别记录最大和最小关键字记录位置  </span></span><br><span class="line">        <span class="keyword">for</span> (j= i+<span class="number">1</span>; j&lt;= n-i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (r[j] &gt; r[max]) &#123;   </span><br><span class="line">                max = j ; <span class="keyword">continue</span> ;   </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">if</span> (r[j]&lt; r[min]) &#123;   </span><br><span class="line">                min = j ;   </span><br><span class="line">            &#125;     </span><br><span class="line">      &#125;    </span><br><span class="line">      <span class="comment">//该交换操作还可分情况讨论以提高效率  </span></span><br><span class="line">      tmp = r[i-<span class="number">1</span>]; r[i-<span class="number">1</span>] = r[min]; r[min] = tmp;  </span><br><span class="line">      tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;   </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序也是选择排序的一种，但是其底层数据结构为树，效率比简单选择排序要高。其时间复杂度为O(nlog(n))。</p>
<p>堆是一棵完全二叉树，分为大顶堆和小顶堆。大顶堆即为根节点大于叶子节点的二叉树，小顶堆相反。堆排序即是每次将堆顶元素输出，剩余元素再建立一个堆，如此循环直到序列有序。</p>
<h5 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;  </span><br><span class="line">        cout&lt;&lt;a[j] &lt;&lt;<span class="string">"  "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已知H[s…m]除了H[s] 外均满足堆的定义</span></span><br><span class="line"><span class="comment"> * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> H是待调整的堆数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s是待调整的数组元素的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length是数组的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> s, <span class="keyword">int</span> length)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp  = H[s];  </span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span>*s+<span class="number">1</span>; <span class="comment">//左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)  </span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; length) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(child+<span class="number">1</span> &lt;length &amp;&amp; H[child]&lt;H[child+<span class="number">1</span>]) &#123; <span class="comment">// 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)  </span></span><br><span class="line">            ++child ;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(H[s]&lt;H[child]) &#123;  <span class="comment">// 如果较大的子结点大于父结点  </span></span><br><span class="line">            H[s] = H[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点  </span></span><br><span class="line">            s = child;       <span class="comment">// 重新设置s ,即待调整的下一个结点的位置  </span></span><br><span class="line">            child = <span class="number">2</span>*s+<span class="number">1</span>;  </span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;            <span class="comment">// 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出  </span></span><br><span class="line">             <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        H[s] = tmp;         <span class="comment">// 当前待调整的结点放到比其大的孩子结点位置上  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    print(H,length);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始堆进行调整</span></span><br><span class="line"><span class="comment"> * 将H[0..length-1]建成堆</span></span><br><span class="line"><span class="comment"> * 调整完之后第一个元素是序列的最小的元素</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildingHeap</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> length)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//最后一个有孩子的节点的位置 i=  (length -1) / 2  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (length -<span class="number">1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; --i)  </span><br><span class="line">        HeapAdjust(H,i,length);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序算法</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> length)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//初始堆  </span></span><br><span class="line">    BuildingHeap(H, length);  </span><br><span class="line">    <span class="comment">//从最后一个元素开始对序列进行调整  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//交换堆顶元素H[0]和堆中最后一个元素  </span></span><br><span class="line">        <span class="keyword">int</span> temp = H[i]; H[i] = H[<span class="number">0</span>]; H[<span class="number">0</span>] = temp;  </span><br><span class="line">        <span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整  </span></span><br><span class="line">        HeapAdjust(H,<span class="number">0</span>,i);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> H[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;  </span><br><span class="line">    cout&lt;&lt;<span class="string">"初始值："</span>;  </span><br><span class="line">    print(H,<span class="number">10</span>);  </span><br><span class="line">    HeapSort(H,<span class="number">10</span>);  </span><br><span class="line">    <span class="comment">//selectSort(a, 8);  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">"结果："</span>;  </span><br><span class="line">    print(H,<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序是交换排序的一种，和简单选择排序一样是最经典的排序算法，这两个也是笔者最先接触的两种排序算法。冒泡排序是依次比较相邻两个元素，大的下沉，小的上浮，就像气泡一样，因此叫做冒泡排序。它的时间复杂度和直接选择排序一样，都是O(n^2)。</p>
<h6 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; n-<span class="number">1</span>; ++i) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; ++j) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">int</span> tmp = a[j] ; a[j] = a[j+<span class="number">1</span>] ;  a[j+<span class="number">1</span>] = tmp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="冒泡算法的改进"><a href="#冒泡算法的改进" class="headerlink" title="冒泡算法的改进"></a>冒泡算法的改进</h5><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>
<p>1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
<p>改进后算法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_1</span> <span class="params">( <span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i= n -<span class="number">1</span>;  <span class="comment">//初始时,最后位置保持不变  </span></span><br><span class="line">    <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;   </span><br><span class="line">        <span class="keyword">int</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; i; j++)  </span><br><span class="line">            <span class="keyword">if</span> (r[j]&gt; r[j+<span class="number">1</span>]) &#123;  </span><br><span class="line">                pos= j; <span class="comment">//记录交换的位置   </span></span><br><span class="line">                <span class="keyword">int</span> tmp = r[j]; r[j]=r[j+<span class="number">1</span>];r[j+<span class="number">1</span>]=tmp;  </span><br><span class="line">            &#125;   </span><br><span class="line">        i= pos; <span class="comment">//为下一趟排序作准备  </span></span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
<p>改进后的算法实现为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_2</span> <span class="params">( <span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">int</span> high= n -<span class="number">1</span>; <span class="comment">//设置变量的初始值  </span></span><br><span class="line">    <span class="keyword">int</span> tmp,j;  </span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者  </span></span><br><span class="line">            <span class="keyword">if</span> (r[j]&gt; r[j+<span class="number">1</span>]) &#123;  </span><br><span class="line">                tmp = r[j]; r[j]=r[j+<span class="number">1</span>];r[j+<span class="number">1</span>]=tmp;  </span><br><span class="line">            &#125;   </span><br><span class="line">        --high;                 <span class="comment">//修改high值, 前移一位  </span></span><br><span class="line">        <span class="keyword">for</span> ( j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者  </span></span><br><span class="line">            <span class="keyword">if</span> (r[j]&lt;r[j-<span class="number">1</span>]) &#123;  </span><br><span class="line">                tmp = r[j]; r[j]=r[j-<span class="number">1</span>];r[j-<span class="number">1</span>]=tmp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        ++low;                  <span class="comment">//修改low值,后移一位  </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序也是一种交换排序，它被称为最快的排序算法。</p>
<h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><ul>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</li>
<li>此时基准元素在其排好序后的正确位置</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</li>
</ul>
<h5 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;  </span><br><span class="line">        cout&lt;&lt;a[j] &lt;&lt;<span class="string">"  "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp = *a;  </span><br><span class="line">    *a = *b;  </span><br><span class="line">    *b = tmp;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> privotKey = a[low];                             <span class="comment">//基准元素  </span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;                                   <span class="comment">//从表的两端交替地向中间扫描  </span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  </span></span><br><span class="line">        swap(&amp;a[low], &amp;a[high]);  </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  </span><br><span class="line">        swap(&amp;a[low], &amp;a[high]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    print(a,<span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;  </span><br><span class="line">        <span class="keyword">int</span> privotLoc = partition(a,  low,  high);  <span class="comment">//将表一分为二  </span></span><br><span class="line">        quickSort(a,  low,  privotLoc -<span class="number">1</span>);          <span class="comment">//递归对低子表递归排序  </span></span><br><span class="line">        quickSort(a,   privotLoc + <span class="number">1</span>, high);        <span class="comment">//递归对高子表递归排序  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;  </span><br><span class="line">    cout&lt;&lt;<span class="string">"初始值："</span>;  </span><br><span class="line">    print(a,<span class="number">10</span>);  </span><br><span class="line">    quickSort(a,<span class="number">0</span>,<span class="number">9</span>);  </span><br><span class="line">    cout&lt;&lt;<span class="string">"结果："</span>;  </span><br><span class="line">    print(a,<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>排序步骤：</p>
<p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i +1、n-m。</p>
<ul>
<li>j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标</li>
<li>若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束<br>//选取r[i]和r[j]较小的存入辅助数组rf</li>
<li>如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵，否则，rf[k]=r[j]； j++； k++； 转⑵<br>  //将尚未处理完的子表中元素存入rf</li>
<li>如果i&lt;=m，将r[i…m]存入rf[k…n] //前一子表非空，如果j&lt;=n ,  将r[j…n] 存入rf[k…n] //后一子表非空</li>
<li>合并结束。</li>
</ul>
<h5 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j,k;  </span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(r[j] &lt; r[i]) rf[k] = r[j++];  </span><br><span class="line">        <span class="keyword">else</span> rf[k] = r[i++];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m)  rf[k++] = r[i++];  </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n)  rf[k++] = r[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并的迭代算法"><a href="#归并的迭代算法" class="headerlink" title="归并的迭代算法"></a>归并的迭代算法</h5><p>1 个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1 个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1 外，其余子表长度均为2。再进行两两合并，直到生成n 个元素按关键码有序的表。</p>
<h6 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;  </span><br><span class="line">        cout&lt;&lt;a[j] &lt;&lt;<span class="string">"  "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j,k;  </span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(r[j] &lt; r[i]) rf[k] = r[j++];  </span><br><span class="line">        <span class="keyword">else</span> rf[k] = r[i++];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m)  rf[k++] = r[i++];  </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n)  rf[k++] = r[j++];  </span><br><span class="line">    print(rf,n+<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> lenght)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> len </span>= <span class="number">1</span>;  </span><br><span class="line">    ElemType *q = r ;  </span><br><span class="line">    ElemType *tmp ;  </span><br><span class="line">    <span class="keyword">while</span>(len &lt; lenght) &#123;  </span><br><span class="line">        <span class="keyword">int</span> s = len;  </span><br><span class="line">        len = <span class="number">2</span> * s ;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(i+ len &lt;lenght)&#123;  </span><br><span class="line">            Merge(q, rf,  i, i+ s-<span class="number">1</span>, i+ len-<span class="number">1</span> ); <span class="comment">//对等长的两个子表合并  </span></span><br><span class="line">            i = i+ len;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i + s &lt; lenght)&#123;  </span><br><span class="line">            Merge(q, rf,  i, i+ s -<span class="number">1</span>, lenght -<span class="number">1</span>); <span class="comment">//对不等长的两个子表合并  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        tmp = q; q = rf; rf = tmp; <span class="comment">//交换q,rf，以保证下一趟归并时，仍从q 归并到rf  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;  </span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>];  </span><br><span class="line">    MergeSort(a, b, <span class="number">10</span>);  </span><br><span class="line">    print(b,<span class="number">10</span>);  </span><br><span class="line">    cout&lt;&lt;<span class="string">"结果："</span>;  </span><br><span class="line">    print(a,<span class="number">10</span>);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="两路归并的递归算法"><a href="#两路归并的递归算法" class="headerlink" title="两路归并的递归算法"></a>两路归并的递归算法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElemType *r, ElemType *rf,<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ElemType *rf2;  </span><br><span class="line">    <span class="keyword">if</span>(s==t) r[s] = rf[s];  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">int</span> m=(s+t)/<span class="number">2</span>;          <span class="comment">/*平分*p 表*/</span>  </span><br><span class="line">        &#123;   </span><br><span class="line">        MSort(r, rf2, s, m);        <span class="comment">/*递归地将p[s…m]归并为有序的p2[s…m]*/</span>  </span><br><span class="line">        MSort(r, rf2, m+<span class="number">1</span>, t);      <span class="comment">/*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/</span>  </span><br><span class="line">        Merge(rf2, rf, s, m+<span class="number">1</span>,t);   <span class="comment">/*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort_recursive</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/*对顺序表*p 作归并排序*/</span>  </span><br><span class="line">    MSort(r, rf,<span class="number">0</span>, n-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>说基数排序之前，我们先说桶排序：</p>
<h5 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h5><p>桶排序是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。  </p>
<p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序  首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储   (10..20]的整数，……集合B[i]存储( (i-1)<em>10, i</em>10]的整数，i   =   1,2,..100。总共有  100个桶。然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。  再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任  何排序法都可以。<br>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。  </p>
<p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是:<br>O(n   +   m   <em>   n/m</em>log(n/m))   =   O(n   +   nlogn   -   nlogm)<br>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)  </p>
<p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的  ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。  </p>
<p>前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p>
<ul>
<li><p>首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>
</li>
<li><p>其次待排序的元素都要在一定的范围内等等。</p>
</li>
</ul>
<p>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。分配排序的基本思想：说白了就是进行多次的桶式排序。</p>
<p>基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)  </p>
<h5 id="基于LSD方法的链式基数排序的基本思想"><a href="#基于LSD方法的链式基数排序的基本思想" class="headerlink" title="基于LSD方法的链式基数排序的基本思想"></a>基于LSD方法的链式基数排序的基本思想</h5><p>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。</p>
<h5 id="基数排序-1"><a href="#基数排序-1" class="headerlink" title="基数排序"></a>基数排序</h5><p>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">RadixSort</span><span class="params">(Node L[],length,maxradix)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> m,n,k,lsp;  </span><br><span class="line">   k=<span class="number">1</span>;m=<span class="number">1</span>;  </span><br><span class="line">   <span class="keyword">int</span> temp[<span class="number">10</span>][length-<span class="number">1</span>];  </span><br><span class="line">   Empty(temp); <span class="comment">//清空临时空间  </span></span><br><span class="line">   <span class="keyword">while</span>(k&lt;maxradix) <span class="comment">//遍历所有关键字  </span></span><br><span class="line">   &#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="comment">//分配过程  </span></span><br><span class="line">    &#123;  </span><br><span class="line">       <span class="keyword">if</span>(L[i]&lt;m)  </span><br><span class="line">          Temp[<span class="number">0</span>][n]=L[i];  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">          Lsp=(L[i]/m)%<span class="number">10</span>; <span class="comment">//确定关键字  </span></span><br><span class="line">       Temp[lsp][n]=L[i];  </span><br><span class="line">       n++;  </span><br><span class="line">   &#125;  </span><br><span class="line">   CollectElement(L,Temp); <span class="comment">//收集  </span></span><br><span class="line">   n=<span class="number">0</span>;  </span><br><span class="line">   m=m*<span class="number">10</span>;  </span><br><span class="line">  k++;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>我们希望能线性的时间复杂度排序，如果一个一个比较，显然是不实际的，书上也在决策树模型中论证了，比较排序的情况为nlogn 的复杂度。既然不能一个一个比较，我们想到一个办法，就是如果在排序的时候就知道他的位置，那不就是扫描一遍，把他放入他应该的位置不就可以了。 要知道他的位置，我们只需要知道有多少不大于他不就可以了吗？</p>
<h5 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countsort(<span class="keyword">int</span> A[])&#123;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length]; <span class="comment">//to store result after sorting</span></span><br><span class="line">        <span class="keyword">int</span> k = max(A);</span><br><span class="line">        <span class="keyword">int</span> [] C = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>]; <span class="comment">// to store temp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;    </span><br><span class="line">            C[A[i]] = C[A[i]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小于等于A[i]的数的有多少个, 存入数组C</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;C.length;i++)&#123;</span><br><span class="line">            C[i] = C[i] + C[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逆序输出确保稳定-相同元素相对顺序不变</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line">            B[C[A[i]]-<span class="number">1</span>] = A[i];</span><br><span class="line">            C[A[i]] = C[A[i]]-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/排序/" rel="tag"># 排序</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/01/TCP协议与UDP协议/" rel="next" title="TCP协议与UDP协议">
                <i class="fa fa-chevron-left"></i> TCP协议与UDP协议
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/10/查找/" rel="prev" title="查找">
                查找 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/海贼3.jpg"
               alt="zhengrui" />
          <p class="site-author-name" itemprop="name">zhengrui</p>
           
              <p class="site-description motion-element" itemprop="description">读书、健身、旅行</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">119</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhezaoyizhuding" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/3017970752/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/profile.php?id=100012335677489" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://yk1062008412.github.io" title="我康军的博客" target="_blank">我康军的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://zhezaoyizhuding.github.io/about/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%862.2.pdf" title="我的简历" target="_blank">我的简历</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">1.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本思想"><span class="nav-number">1.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作步骤"><span class="nav-number">1.2.</span> <span class="nav-text">操作步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例"><span class="nav-number">1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希尔排序"><span class="nav-number">2.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#代码示例-1"><span class="nav-number">2.0.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单选择排序"><span class="nav-number">3.</span> <span class="nav-text">简单选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-2"><span class="nav-number">3.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单选择排序的改进–二元选择排序"><span class="nav-number">4.</span> <span class="nav-text">简单选择排序的改进–二元选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-3"><span class="nav-number">4.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序"><span class="nav-number">5.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-4"><span class="nav-number">5.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序"><span class="nav-number">6.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#代码示例-5"><span class="nav-number">6.0.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡算法的改进"><span class="nav-number">6.1.</span> <span class="nav-text">冒泡算法的改进</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">7.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本思想-1"><span class="nav-number">7.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-6"><span class="nav-number">7.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">8.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-7"><span class="nav-number">8.1.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#归并的迭代算法"><span class="nav-number">8.2.</span> <span class="nav-text">归并的迭代算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#代码示例-8"><span class="nav-number">8.2.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两路归并的递归算法"><span class="nav-number">8.3.</span> <span class="nav-text">两路归并的递归算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基数排序"><span class="nav-number">9.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本思想-2"><span class="nav-number">9.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于LSD方法的链式基数排序的基本思想"><span class="nav-number">9.2.</span> <span class="nav-text">基于LSD方法的链式基数排序的基本思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基数排序-1"><span class="nav-number">9.3.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法实现"><span class="nav-number">9.4.</span> <span class="nav-text">算法实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数排序"><span class="nav-number">10.</span> <span class="nav-text">计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法实现-1"><span class="nav-number">10.1.</span> <span class="nav-text">算法实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhengrui</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zhezaoyizhuding.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://zhezaoyizhuding.github.io/2017/04/10/排序/';
          this.page.identifier = '2017/04/10/排序/';
          this.page.title = '排序';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://zhezaoyizhuding.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  













  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("GW32OlXJkBeGE31qrywcmn3a-gzGzoHsz", "1fFuhB2mWMfLiuVyDPOv6dll");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

</body>
</html>
